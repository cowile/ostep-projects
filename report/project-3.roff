.RP
.
.
.
.TL
Advanced Operating Systems Project 3
.AU
Colton Lewis
.AI
University of Texas Austin
.DA
.AB
Describe the implementation techniques used by the author to implement null pages, memory protection, kernel threads, and ticket locks in the Xv6 operating system. A high level summary of the implementation is provided for each task followed by detailed commentary on the patches to the codebase provided by the instructor.
.AE
.
.
.
.NH 1
Null Pages
.NH 2
Objective
.PP
Implement memory protection such that a user program dereferencing a null pointer will immediately crash with an exception.
.NH 2
Method Summary
.PP
When
.CW exec
loads a program into memory, allocate an additional page at virtual address 0 that is not accessible to userspace. If a userspace process dereferences a pointer to anywhere in this null page, a page fault crashes the process.
.NH 2
Code Commentary
.PP
The most important change, the bedrock of this method, is a couple of additional lines in
.CW exec .
.CW exec
is the system call in Xv6 and all Unix based operating systems that loads executable programs from files into memory and begins executing them.
.CW exec
works in tandem with
.CW fork ,
which creates a process by copying the current process.
.CW exec 's
workings can be roughly divided into reading the executable file, allocating memory for the executable code, copying the instructions to memory, and chaging the process state to run the newly loaded code. Supporting null pages requires a change to the memory allocation.
.DS I
  // Allocate null pages.
  if((sz = allocuvm(pgdir, sz, USER_VA_START)) == 0)
    goto bad;
  // Make it inacceccible to users.
  clearpteu(pgdir, (char *)0);
.DE
.PP
These lines accomplish two things. The first is handled by
.CW allocuvm ,
which does the allocation of the null page at address 0. Address 0 is the first address in every virtual address space. With this change, every process now has an additional null page. The second is handled by
.CW clearpteu ,
which clears the Page Table Entry User
.CW PTE_U ) (
flag to prevent any user process from accessing it. Allocating a physical page that will hold no data is a bit wasteful, but it is the most convenient technique that requires the fewest changes to other parts of the code. It is the exact same method used further down in
.CW exec
to create a guard page preventing stack overflow.
.CW USER_VA_START
is a newly created macro to mark where the user virtual address space starts. It is defined as the size of one page.
.PP
Changing where executable code will be located in its virtual address space changes some assumptions elsewhere. The first is in the makefile that builds Xv6.
.CW -fno-delete-null-pointer-checks
instructs the compiler not to help with null pointer checks so the change may be tested.
.CW "-Ttext 0x1000"
instructs the linker that executables will be loaded at address 0x1000, or 4096, exactly one page of memory above 0.
.PP
The second changed assumption is how the kernel validates pointers passed to system calls. The kernel must now ensure no pointer passed to a system call points to the null page. It checks for this by checking for any virtual address below
.CW USER_VA_START .
.
.
.NH 1
Memory Protection
.NH 2
Objective
.PP
Allow user programs to mark pages of memory as writable or not.
.NH 2
Method Summary
.PP
Implement two new system calls,
.CW mprotect
and
.CW munprotect .
The former allows a process to protect pages of memory by marking them as not writable, preventing future mistakes doing so unintentionally. The latter marks pages writable. This is similar to what was done for null pages, but this will use the Page Table Entry Writable
.CW PTE_W ) (
flag instead.
.NH 2
Code Commentary
.PP
To start, there are formalities to declare a new system call. New system calls must be added to defs.h, syscall.h, syscall.c, user.h, and usys.S. These changes are not interesting enough to include. They only involve declaring the system call in the right places and assigning it a unique number.
.PP
What follows is the actual implementation. Both system calls where implemented in terms of a third, more general function called
.CW mmark ,
which takes additional parameters and can set or clear any page flags. It iterates through the pages specified, looks up the page table entry of the virtual address using the function
.CW walkpgdir ,
and if the page is present, it sets or clears the flags
.CW flags
depending on the value of
.CW set .
This allows us to implement
.CW mprotect
as
.CW "mmark(addr, len, 0, PTE_W)"
and
.CW munprotect
as
.CW "mmark(addr, len, 1, PTE_W)" .
After that, there is the additional work of defining the entry points
.CW sys_mprotect
and
.CW sys_munprotect
to validate the arguments passed in before giving them to the main functions. Argument validation is not included either since it is merely using the
.CW argint
and
.CW argptr
functions to validate each argument and return failure if any are invalid.
.DS I
// mmark
// Starting at addr, set len pages with the given permissions.
int mmark(void *addr, int len, int set, int flag)
{
  struct proc *curproc = myproc();
  pte_t *pgdir = curproc->pgdir;
  pte_t *pgtab_ent;

  for(int i = 0; i < len; i++)
  {
    if((pgtab_ent = walkpgdir(pgdir, addr + (i * PGSIZE), 0)) == 0)
      return -1;
    if((*pgtab_ent & PTE_P) == 0)
      return -1;
    if(set)
      *pgtab_ent = *pgtab_ent | flag;
    else
      *pgtab_ent = *pgtab_ent & ~flag;
  }

  lcr3(V2P(pgdir));
  return 0;
}
.DE
.
.
.
.NH 1
Kernel Threads
.NH 2
Objective
.PP
Implement system calls for creating multiple threads of execution that run concurrently while sharing the same address space.
.NH 2
Method Summary
.PP
A thread is implemented as a seperate process that shares the same page directory as the parent process and so has access to the same address space. Threads are implemented with two system calls,
.CW clone
and
.CW join .
The former takes a user-defined function and arguments as well as a user-defined stack and creates a new thread executing that function using that stack. The latter waits for a child thread to exit and returns the stack it used.
.NH 2
Code Commentary
.PP
.CW clone
is mostly a copy of
.CW fork .
It allocates a new process and copies information from the parent. The first distinction that makes this a thread is that it shares the address space with the parent. It makes a shallow copy of
.CW pgdir ,
only copying the pointer instead of the underlying structure. The second distinction is that it starts execution for a user-provided function and arguments. The stack needs to be set up according to the x86 calling convention to support accessing the arguments and the process context must appropriately set the stack and instruction registers to start execution from the right place. The code below only shows these differences.
.DS I
  // Use user-allocated stack for kstack.
  memset(stack, 0, KSTACKSIZE);
  np->ustack = stack;
  sp = stack + KSTACKSIZE;

  // Set up arguments for func using cdecl calling convention.
  sp -= 1;
  *sp = (uint)arg_2;
  sp -= 1;
  *sp = (uint)arg_1;
  // Create dummy return pointer for func
  sp -= 1;
  *sp = 0xffffffff;

  // Set stack pointer to point to user stack.
  np->tf->esp = (uint)sp;
  // Set instruction pointer to begin execution at func.
  np->tf->eip = (uint)func;
.DE
.PP
.CW join
is mostly a copy of
.CW wait .
It scans the process table looking for child processes and deallocates them if they have exited. An exited process is indicated by the
.CW ZOMBIE
state. The first distinction is to only act on threads, so there is an additional check to ensure the parent and child process have the same page directory. The second distinction is that the page directory should not be freed with the
.CW freevm
function because multiple other processes may still be using it. The code below only shows these differences.
.DS I
    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
      if(p->parent != curproc)
        continue;
      if(p->pgdir != curproc->pgdir)
        continue;
.DE
.PP
The existence of threads must now be considered in other process handling functions. The first is
.CW exit ,
which must now force a process to join all of its child threads before finishing. The second is
.CW wait ,
which should act only on child processes that are not child threads.
.
.
.
.NH 1
Threading Library
.NH 2
Objective
.PP
Write a threading library to provide a simplified interface for system calls implemented in the previous section and ticket locks to protect globally shared data.
.NH 2
Method Summary
.PP
The system calls in the previous section correspond to user library functions
.CW thread_create
and
.CW thread_clone ,
which support a simplified interface that takes care of allocating and freeing memory for the stack. For locks, there is a type definition
.CW lock_t
along with management functions
.CW lock_init ,
.CW lock_acquire ,
and
.CW lock_release
implementing a simple ticket lock using an underlying atomic fetch-and-add operation.
.NH 2
Code Commentary
.PP
Because locks require atomic operations to operate correctly, define this using inline assembly with
.CW xaddl ,
the x86 instruction that implements fetch-and-add. This implementation was copied from an external link mentioned in the comments.
.DS I
// Copied directly from https://en.wikipedia.org/wiki/Fetch-and-add
static inline int
fetch_and_add(int *variable, int value)
{
  __asm__ volatile("lock; xaddl %0, %1"
                   : "+r" (value), "+m" (*variable) // input+output
                   : // No input-only
                   : "memory"
    );
  return value;
}
.DE
.PP
With the underlying infrastructure in place, the implementation of the user functions are almost self-explanatory. However, it is important that optimizations be disabled for
.CW lock_acquire ,
otherwise checking
.CW lock->turn
on each iteration of the loop will be optimized out and a thread will get stuck in an infinite loop.
